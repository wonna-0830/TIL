# 📌 TIL - Programmers Lv.1 미니퀘스트 정리

## 문제 정보
- **2025.08.12**
- **추억 점수 관련 미니퀘스트**(GPT가 내주는 변형 문제)


## 문제 1

### 문제 요약
> 사진 속에 나오는 인물의 그리움 점수를 모두 합산하여 추억 점수 추출하기
>
> 사람 이름을 담은 문자열 배열 name
> 각 사람 별 그리움 점수를 담은 정수 배열 yearning
> 각 사진에 찍힌 인물의 이름을 담은 이차원 배열 photo
> 
> **단, 사진 배열 중 특정 사람 집함이 전부 포함 된 경우에만 추억 점수를 합상 해 결과 배열에 담는다.**
>
> 예) name = ["may", "kein", "kain", "radi"]
> yearning = [5, 10, 1, 3]
> photo = [
    ["may", "kein", "kain"],
    ["kein", "radi"],
    ["may", "kain", "radi"]
 ]
> requiredSet = ["may", "kain"]
>
> 출력: [16, 0, 9]

### 💡 풀이 아이디어 
- containsAll을 사용해 requiredSet의 배열 전체가 포함되는지 확인
- 대신, containsAll은 리스트로 변환 후에 사용가능하므로 requiredSet을 리스트로 변환
- [참고한 페이지](https://developer-talk.tistory.com/666#google_vignette)

### 🧩 구현 코드
```java
import java.util.*;
class Solution {
    public int[] solution(String[] name, int[] yearning, String[][] photo, String[] requiredSet) {
        Map<String, Integer> score = new HashMap<>();
        for (int i = 0; i < name.length; i++) {
            score.put(name[i], yearning[i]);
        }

        List<String> requiredList = Arrays.asList(requiredList);
    
        int[] answer = new int[photo.length];
        for (int i = 0; i < photo.length; i++) {
            List<String> currentList = Arrays.asList(photo[i]);

            if(currentList.containsAll(requiredList)){
                int sum = 0;
                for(String person : photo[i]){
                    sum += score.getOrDefault(person,0);
                }
                answer[i] = sum;
            } else {
                answer[i] = 0;
            }
        }
        return answer;
    }
}
```

### ⚠️ 실수/배운 점
- 사실 처음에 containsAll을 찾았을 때 배열인지 생각도 못하고 내 마음대로 Map을 만들 때 먼저 필터링을 해서 Map을 만들고 점수 합산을 하면 안되나 생각했는데 가차없이 GPT한테 빠꾸먹어서 읭 그럼 어케 만들어... 했다
- 조금 조금씩 수정한 걸 보여주면서 GPT가 주는 힌트로 혼자 꼼지락꼼지락 대다가 겨우 완성했다...^^


---

## 문제 2

### 문제 요약
> 사진 속에 나오는 인물의 그리움 점수를 모두 합산하여 추억 점수 추출하기
>
> 사람 이름을 담은 문자열 배열 name
> 각 사람 별 그리움 점수를 담은 정수 배열 yearning
> 각 사진에 찍힌 인물의 이름을 담은 이차원 배열 photo
> 
> 단, 사진 배열 중 특정 사람 집함이 전부 포함 된 경우에만 추억 점수를 합상 해 결과 배열에 담는다.
>
> **같은 이름이 사진 안에 3번 이상 나와도 최대 2번까지만 점수 합산.**

### 💡 풀이 아이디어 
- 혼자 풀지 못해서 아이디어라고 할 게 없다.
- [참고한 페이지가 있긴하다.](https://devkuka.tistory.com/143)

### 🧩 구현 코드
```java
import java.util.*;
class Solution {
    public int[] solution(String[] name, int[] yearning, String[][] photo, String[] requiredSet) {
        Map<String, Integer> score = new HashMap<>();
        for (int i = 0; i < name.length; i++) {
            score.put(name[i], yearning[i]);
        }

        List<String> requiredList = Arrays.asList(requiredSet);
    
        int[] answer = new int[photo.length];
        for (int i = 0; i < photo.length; i++) {
            List<String> currentList = Arrays.asList(photo[i]);

            if(!currentList.containsAll(requiredList)){
                answer[i] = 0;
                continue;
            }

            int sum = 0;
            Map<String, Integer> count = new HashMap<>();

            for (int j = 0; j < photo[i].length; j++){
                String person = photo[i][j];
                int occ = count.getOrDefault(person, 0) + 1;
                count.put(person, occ);

                if(occ <= 2){
                    sum += score.getOrDefault(person, 0)
                }
            }
            answer[i] = sum;
        }
        return answer;
    }
}
```

### ⚠️ 실수/배운 점
- 계속 이리저리 만들다가 더이상 머리에 과부하가 와서 GPT한테 답안을 부탁하고 그걸 보면서 왜 이렇게 만들어야되는지 혼자 분석했다.
- 나는 먼저 count에서 2가 되고 나면 점수를 합산하는 로직을 생각했는데 답안을 보니까 count가 2가 될 때까지 점수를 score의 키와 값을 이용해 여러번 더한다는 걸 보고 왜 이걸 생각을 못했지; 했다
- 문제 1에서 조금만 조건을 바꿨을 뿐인데 이렇게까지 사고를 해야된다는게 너무 신기하면서도 착잡하다.
- 근데 하나하나 정확하게 지시해야 돌아가는게 로직이니까 내일 미니퀘스트 남은 2개는 오늘 문제 푼 걸 바탕으로 좀 더 고심해서 만들어야겠다는 생각이 들었다
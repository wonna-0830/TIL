# 📌 TIL - 크기가 작은 부분 문자열 관련 변형 문제

## 미니퀘스트1
- **2025.08.24**
- **크기가 작은 부분 문자열**
- **[관련 링크](https://school.programmers.co.kr/learn/courses/30/lessons/147355)**

## 📝 문제 요약
> 숫자로만 이루어진 문자열 t와, 같은 길이 m의 숫자 문자열 low, high가 주어진다.
t에서 길이 m인 모든 부분문자열을 뽑아 보았을 때, 그 값이 [low, high] (포함 범위) 안에 들어가는 개수를 구하라.
>
> 부분문자열은 선행 0을 포함할 수 있다. (예: "007")
>
> 비교는 문자열 사전식(lexicographical) 비교를 사용하되, low/high와 부분문자열의 길이가 동일하므로 숫자 비교와 동치가 된다.


## 💡 풀이 아이디어 
- subString과 compareTo로 슬라이딩과 사전식 비교

## 🧩 구현 코드
```java
class Solution {
    public int solution(String t, String p, String low, String high) {
        int n = t.length();
        int m = p.length();
        int answer = 0;

        for (int i = 0; i <= n - m; i++) {
            String sub = t.substring(i, i + m); 
            if (sub.compareTo(low) >= 0 && sub.compareTo(high) <= 0) {        
                answer++;
            }
        }
        return answer;
    }
}
```


## ⚠️ 실수/배운 점
- 나는 sub, high, low를 다 정수로 변환해서 비교해야된다고 생각해서 전부 변환한 후 비교하는 로직을 짰었다
- 이거 말고 더 쉬운 방법이 있을거라고 생각하긴 했는데 도무지 모르겠어서 GPT에게 내 답변을 보내면서 더 간단한 답이 있다면 보내달라고 했는데
- 위 로직이었다.....
- 그냥 compareTo로 low는 양수를 반환할 때 (>= 0), high는 음수를 반환할 때 (<= 0)로 조건문을 만들기만 하면 됐다
- 나는 바보다

## 미니퀘스트2
- **2025.08.24**
- **크기가 작은 부분 문자열**
- **[관련 링크](https://school.programmers.co.kr/learn/courses/30/lessons/147355)**

## 📝 문제 요약
> 숫자로만 이루어진 문자열 t와, 같은 길이 m의 숫자 문자열 low, high가 주어진다.
> t에서 길이 m인 모든 부분문자열 중, 값이 [low, high] (포함) 범위에 속하는 것들만 모았을 때, 서로 다른 값의 개수를 구하라.
(같은 값이 여러 번 나와도 한 번만 센다.)
> 
> 부분문자열은 선행 0을 포함할 수 있다. (예: "007")
> 
> 비교는 문자열 사전식 비교를 사용한다. (low.length() == high.length() == m)


## 💡 풀이 아이디어 
- subString과 compareTo로 슬라이딩과 사전식 비교
- ~중복을 허용하지 않는 HashMap 사용~ -> HashSet으로


## 🧩 구현 코드 (GPT 답)
```java
class Solution {
    public int solution(String t, String low, String high) {
        int n = t.length();
        int m = low.length();
        
        Set<String> uniq = new HashSet<>();
        for (int i = 0; i <= n - m; i++) {
            String sub = t.substring(i, i + m);
            if (sub.compareTo(low) >= 0 && sub.compareTo(high) <= 0) {
                uniq.add(sub);
            }
        }
        return uniq.size();
    }
}
```


## 🧩 구현 코드 (내가 한 거)
```java
class Solution {
    public int solution(String t, String low, String high) {
        int n = t.length();
        int m = low.length();
        int answer = 0;

        Map<String, Integer> count = new HashMap<>();
        for (int i = 0; i <= n - m; i++) {
            String sub = t.substring(i, i + m); 
            if (sub.compareTo(low) >= 0 && sub.compareTo(high) <= 0) {        
                count.put(sub);
            }
            answer = count.size();
        }
        return answer;
    }
}
```


## ⚠️ 실수/배운 점
- 저번 미니퀘스트에서 배웠던 HashMap은 중복을 허용하지 않아서 HashMap을 만들고 넣으면 된다는 생각은 했다.
- 답을 보내니 GPT의 답변은 '서로 다른 값 개수'가 목적이면 Map 보다는 Set이 낫다고 했다.
- Map과 Set을 찾아보니 확실히 이 로직에는 키가 필요없고 값만 필요하기 때문에 set이 맞다고 생각했다.
- 그리고 size()는 return하면서 바로 한번만 써도 된다고 했다.(size()를 도출하고 answer에 그 값을 안넣어도 된다는 뜻)
- 한 번 해봤다고 자신감 붙어서 해봤는데 이게 맞는지 아닌지도 자세하게 확인해야겠다고 생각했다.

## Map과 Set의 차이
### Set<E>
- 값의 집합
  - 중복 없음
  - 한 원소가 존재하냐가 포인트
  - add, contains, remove, size
### Map<K,V>
- 키->값 사전
  - 키는 중복 없음, 값은 중복 가능
  - 키로 값을 찾는 구조
  - put, get, containsKey, remove, size

## subString이란?
- 문자열을 원하는 위치에서 잘라서 리턴하는 함수
- str.subString(n);
  - index가 n인 위치의 문자부터 끝까지 추출
- str.subString(n, m)
  - 문자열 시작부분(n)과 끝부분(m)을 지정해 특정 문자열을 추출

## compareTo이란?
- 문자열이나 숫자 등 비교 가능한 객체들의 순서를 비교하고, 그 결과를 int 값으로 반환
- 두 객체의 값이 같으면 0, 첫번째 객체가 더 크면 양수, 작으면 음수를 반환


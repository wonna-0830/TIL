Mini-Quest 1 (Set): 나머지 그룹의 개수
문제

정수 배열 nums와 양의 정수 m이 주어진다.
각 원소를 m으로 나눈 나머지를 구했을 때, 서로 다른 나머지의 개수를 구하라.

모든 나머지는 0 이상 m-1 이하.

중복되는 나머지는 한 번만 센다.

함수 시그니처 (Java)
int countDistinctRemainders(int[] nums, int m)

입출력 예

입력: nums = [1,2,3,4,5], m = 3
출력: 3 // 나머지들: [1,2,0,1,2] → 서로 다른 값 {0,1,2}

입력: nums = [10,20,30], m = 7
출력: 3 // [3,6,2] → {2,3,6}

입력: nums = [0,0,0], m = 5
출력: 1 // [0,0,0] → {0}

제약

1 ≤ nums.length ≤ 100,000

0 ≤ nums[i] ≤ 1,000,000,000

1 ≤ m ≤ 100,000

힌트

Set<Integer>에 nums[i] % m을 넣고, 최종 set.size()를 반환하면 된다.

🧩 Mini-Quest 2 (Map): 최다 주문 메뉴 찾기
문제

문자열 배열 orders가 주어진다. 각 문자열은 주문된 메뉴 이름이다.
가장 많이 주문된 메뉴 이름을 반환하라.
동률일 경우, 사전순(lexicographical) 으로 더 앞서는 메뉴를 반환한다.
(대소문자는 구분한다고 가정; 즉 "Latte"와 "latte"는 다른 메뉴.)

함수 시그니처 (Java)
String mostOrdered(String[] orders)

입출력 예

입력: ["americano","latte","latte","mocha","latte"]
출력: "latte"

입력: ["tea","coffee","tea","coffee"]
출력: "coffee" // 빈도 동률(2,2) → 사전순 "coffee" < "tea"

입력: ["waffle"]
출력: "waffle"

제약

1 ≤ orders.length ≤ 100,000

1 ≤ |orders[i]| ≤ 30 (영문, 공백 없음)

힌트

Map<String,Integer>로 빈도수를 세고,
순회하며 (더 큰 빈도), (동률이면 이름이 더 앞서는지) 기준으로 최고값을 갱신하자.

갱신 조건 예시:

cnt > maxCnt → 갱신

cnt == maxCnt && name.compareTo(bestName) < 0 → 갱신
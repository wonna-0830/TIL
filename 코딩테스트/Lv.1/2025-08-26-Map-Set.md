# 📌 TIL - Mini Quests (Set & Map)
- **2025.08.26**
- 8월 12일 미니퀘스트 중 Set과 Map의 차이를 알기 위한 기초 문제 (문제 출처: GPT)

## 🧩 Mini-Quest 1 (Set): 나머지 그룹의 개수

### 📝 문제 설명
> 정수 배열 nums와 양의 정수 m이 주어진다.
> 각 원소를 m으로 나눈 나머지를 구했을 때, 서로 다른 나머지의 개수를 구하라.
>
> 모든 나머지는 0 이상 m-1 이하
>
> 중복되는 나머지는 한 번만 센다.
>

### 입출력 예
```
입력: nums = [1,2,3,4,5], m = 3
출력: 3
(나머지: [1,2,0,1,2] → 서로 다른 값 {0,1,2})

입력: nums = [10,20,30], m = 7
출력: 3
(나머지: [3,6,2] → {2,3,6})

입력: nums = [0,0,0], m = 5
출력: 1
(나머지: [0,0,0] → {0})
```

### 💡 풀이 아이디어
- 서로 다른 나머지의 개수이므로 Set 사용
- 반복문을 통해 각각의 정수 배열에 접근해서 m으로 나눈 나머지를 변수에 저장 후 Set 내에 삽입
- .size()를 통해 개수 카운트

### 🧩 구현 코드
```java

class Solution {
    public int countDistinctRemainders(int[] nums, int m) {
        Set<Integer> rest = new HashSet<>();
        int remainder = 0;
        for(int i = 0; i < nums.length; i++){
            remainder = nums[i] % m;
            rest.add(remainder);
        }
        return rest.size();
    }
}
```

### ⚠️ 실수/배운 점
- 처음으로 혼자서 완벽하게 클리어!!!!!!!
- 아주아주 쉬운 문제였지만 혼자서 풀었다는 점 하나로도 충분히 뿌듯했다.


---

## 🧩 Mini-Quest 2 (Map): 최다 주문 메뉴 찾기

### 📝 문제 설명
> 문자열 배열 orders가 주어진다. 각 문자열은 주문된 메뉴 이름이다.
> 가장 많이 주문된 메뉴 이름을 반환하라.
>
> 동률일 경우, 사전순(lexicographical) 으로 더 앞서는 메뉴를 반환한다.
>
> 대소문자는 구분 (즉 "Latte"와 "latte"는 다른 메뉴).



### 입출력 예
```
입력: ["americano","latte","latte","mocha","latte"]
출력: "latte"

입력: ["tea","coffee","tea","coffee"]
출력: "coffee"
(빈도 동률 → 사전순 "coffee" < "tea")

입력: ["waffle"]
출력: "waffle"
```


### 💡 풀이 아이디어
- 메뉴와 주문횟수를 연결해서 넣어야하므로 Map 사용
- for문을 이용해 순회하면서 반복되는 String 배열은 value 값에 +1
- 그다음에서 막힘!!!!!!

### 🧩 구현 코드
```java
class Solution {
    public String mostOrdered(String[] orders) {
        Map<String, Integer> orderList = new HashMap<>();
        int maxCnt = -1;
        String bestName = "";
        
        for (String s: orders){
            orderList.put(s, orderList.getOrDefault(s,0)+1);
        }

        for(Map.Entry<String, Integer> e: orderList.entrySet()){
            String name = e.getKey();
            int count = e.getValue();

            if(count > maxCnt || (count == maxCnt && name.compareTo(bestName) < 0)){
                maxCnt = count;
                bestName = name;
            }
        }
        return bestName;
    }
}
```

### ⚠️ 실수/배운 점
- 첫번째 for문은 이전에도 했어서 쉽게 주문 횟수를 기록할 수 있었다.
- 그런데 여기서 가장 많이 주문된 메뉴 중에서 사전순으로 앞서는 메뉴 이름을 추출하라고 하는 여러개의 조건 때문에 머리가 잘 안돌아가서 GPT에게 코드 없이 힌트를 부탁했다.....
- 결국 두번째 for문까지는 만들었지만 조건 세우는 게 잘 안돼서 도움을 받았다.
- 항상 느끼는 거지만 하고나면 이해가 쏙쏙 된다;; 에바슨
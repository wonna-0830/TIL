# 📌 TIL - Programmers Lv.1 풀이 정리

## 문제 정보
- **2025.08.11**
- **추억 점수**
- **[링크](https://school.programmers.co.kr/learn/courses/30/lessons/176963)**

## 📝 문제 요약
> 사진 속에 나오는 인물의 그리움 점수를 모두 합산하여 추억 점수 추출하기
>
> 사람 이름을 담은 문자열 배열 name
> 각 사람 별 그리움 점수를 담은 정수 배열 yearning
> 각 사진에 찍힌 인물의 이름을 담은 이차원 배열 photo
> 
> 예) 사진 속 인물의 이름이 `["kali", "mari", "don", "tony"]`이고 `["kali", "mari", "don"]`의 그리움 점수가 각각 `[11점, 1점, 55점]`이고, "tony"는 그리움 점수가 없을 때, 이 사진의 추억 점수는 3명의 그리움 점수를 합한 `67(11 + 1 + 55)`점

## 💡 풀이 아이디어 
- name과 yearning을 MAP으로 만들고, photo[]의 각 배열들을 돌면서 점수를 합산

## 🧩 구현 코드
```java
import java.util.*;
class Solution {
    public int[] solution(String[] name, int[] yearning, String[][] photo) {
        Map<String, Integer> score = new HashMap<>();
        for (int i = 0; i < name.length; i++) {
            score.put(name[i], yearning[i]);
        }

        int[] answer = new int[photo.length];
        for (int i = 0; i < photo.length; i++) {
            int sum = 0;
            for (String person : photo[i]) {
                sum += score.getOrDefault(person, 0);
            }
            answer[i] = sum;
        }
        return answer;
    }
}
```


## ⚠️ 실수/배운 점
- name과 yearning은 같은 위치에 연결시켜야하니까 딕셔너리로 만드는 것 까지는 생각을 했는데, 그 이후로 맵핑해서 점수를 더하는 거 까지는 생각을 못했다.
- 그래서 chatGPT에게 내가 참고할 수 있는 힌트를 달라고 했는데 진짜 모르겠어서 답을 참고했다.
- 대신 GPT에게 비슷한 문제를 몇개 더 만들어달라고 해서 더 풀어봤다.
- `for ( : ) { ... }` (각 항목을 나타내는 변수 : 반복가능한 객체)
- 배열이나 문자열등의 컬렉션에서 각 항목을 순회하며 반복 작업이 가능하다
- `getOrDefault(Object key, V DefaultValue)` -> 찾는 키가 존재하면 키에 매핑된 값을 반환하고, 아니면 디폴트 값이 반환


---

## GPT 문제 1

> 플레이리스트 무드 점수
> 
> track: 각 노래의 제목을 담은 문자열 배열
> mood: 각 노래의 무드 점수를 담은 정수 배열 (track[i] ↔ mood[i] 1:1 매핑)
> playlists: 여러 플레이리스트(각각 노래 제목 배열)를 담은 2차원 문자열 배열

> 각 플레이리스트의 총 무드 점수를 계산해서, playlists 순서대로 int[]로 반환하라.
> 플레이리스트 안에 track에 없는 노래가 있으면 그 노래의 점수는 0점으로 본다.

```java
import java.util.*;
class Solution {
    public int[] solution(String[] track, int[] mood, String[][] playlists){
        int[] result = new int[playlists.length];
    
        Map<String, Integer> score = new HashMap<>();
    
        for(int i = 0; i < track.length; i++){
            score.put(track[i], mood[i]);
        }
     
        for(int i = 0; i < playlists.length; i++){
            int sum = 0;
            for(String song : playlists[i]){
                sum += score.getOrDefault(song, 0);
            }
           result[i] = sum;
        }
        return result;
    }
}
```

---

## GPT 문제 2

> 장바구니 총액 계산
> 
> item: 판매 중인 상품 이름 배열
> price: 각 상품의 가격 배열 (item[i] ↔ price[i] 1:1 매핑)
> carts: 여러 명의 장바구니(각각 상품 이름들의 배열)를 담은 2차원 배열
> 각 장바구니의 총 금액을 구해서 carts 순서대로 int[]로 반환하라.
> 장바구니에 가격표에 없는 상품이 있으면 그 상품 가격은 0원으로 취급한다.

```java
import java.util.*;
class Solution {
    public int[] solution(String[] item, int[] price, String[][] carts){
        int[] result = new int[carts.length];
        Map<String, Integer> priceMap = new HashMap<>();

        for(int i = 0; i < item.length; i++){
            priceMap.put(item[i], price[i]);
        }

        for(int i = 0; i < carts.length; i++){
            int sum = 0;
            for(int j = 0; j < carts[i].length; j++){
                String shop = carts[i][j];
                sum += priceMap.getOrDefault(shop, 0);
            }
            result[i] = sum;
        }
        return result;
    }
}
```

---

## GPT 문제 3

> 사진 속에 나오는 인물의 그리움 점수를 모두 합산하여 추억 점수 추출하기
>
> 사람 이름을 담은 문자열 배열 name
> 각 사람 별 그리움 점수를 담은 정수 배열 yearning
> 각 사진에 찍힌 인물의 이름을 담은 이차원 배열 photo
>
> **단, 각 사진에 대해 같은 사람이 여러번 나오더라도 한 번만 점수에 반영해서 합계를 구하라**

```java
import java.util.*;
class Solution {
    public int[] solution(String[] name, int[] yearning, String[][] photo) {
        Map<String, Integer> score = new HashMap<>();
        for (int i = 0; i < name.length; i++) {
            score.put(name[i], yearning[i]);
        }

        int[] answer = new int[photo.length];
        for (int i = 0; i < photo.length; i++) {
            int sum = 0;
            Set<String> seen = new HashSet<>(); 
            for (String person : photo[i]) { 
                if (seen.add(person)) { 
                    sum += score.getOrDefault(person, 0);
                }
            answer[i] = sum;
            }
        }
        return answer;
    }
}
```
- Map과 다르게 Set은 중복 허용 X
- `for (String person : photo[i]) { ` -> photo[i]의 문자열이 하나씩 person에 들어옴
- `if (seen.add(person)) { `으로 이미 들어왔던 동일 문자열인지 아닌지 boolean
- true 일때만 if내 로직 수행